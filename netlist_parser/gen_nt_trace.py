import os, sys
sys.path.append(os.path.dirname(os.path.realpath(__file__)))

from tt_simple_netlist import SimpleNetList
from netrace.nt_trace_handler import NTHeader, NTPacket, NTTrace
from tt_pipe import Pipe
from tt_device import Device
from collections import deque
from tt_coordinate import OnChipCoordinate

def generate_trace(netlist, out_file):
    
    for name, temporal_epoch in netlist.temporal_epochs.items():
        # Prepocess phase 0: connect the buffers that feeds to an op and is generated by that op. 
        
        # The precise buffer connections are maintained by tensix kernels. The compiler may introduce many latency optimization methods such as async noc write. 
        # FIXME: Our approximation here just assumes that all op's output buffers/pipes should be blocked until all inputs arrives. 
        # This could collapse the temporal dimensions (the 't' dim in operations) thus disallows all pipelines. 
        for graph in temporal_epoch.graphs.values():
            for op in graph.op_names():
                in_buffers = graph.get_buffers(graph.ops[op], "out")       # "out" means the buffer is the output of the pipe, thus it is the input of the op
                out_buffers = graph.get_buffers(graph.ops[op], "in")
                coords = [
                    OnChipCoordinate(*c, "netlist", graph.device)  # netlist coordinates
                    for c in graph.get_op_netlist_coords(op)       
                ]
                # Get the input and output buffers for op at coords c
                for c in coords:
                    in_buffers_at_c = [i for i in in_buffers.values() if i._id in graph.get_core_buffers(c.to("netlist"))]
                    out_buffers_at_c = [o for o in out_buffers.values() if o._id in graph.get_core_buffers(c.to("netlist"))]

                    # We maintain an all to all connection for buffers that are generated by the same op at the same core.
                    for i in in_buffers_at_c:
                        i.connect_buffers_of_same_op(out_buffers_at_c, "out")
                    for o in out_buffers_at_c:
                        o.connect_buffers_of_same_op(in_buffers_at_c, "in")

        for i in temporal_epoch.buffers.values():
            if not i.is_dram_buffer() and not i.is_intermediate_buffer():
                if len(i.input_buffer_of_same_op) == 0 and len(i.output_buffer_of_same_op) == 0:
                    raise ValueError(f"Buffer {i} is not a dram buffer, but not connected to any other buffers of the same op")

        # Preprocess: phase-1: get the number of dependent nodes, reduce bfs algorithm complexity
        pipes = temporal_epoch.pipes
        # streams = temporal_epoch.streams

        for p in pipes.values():
            p.dep_size = len(p.predecessor_pipes())
            p.msg_size = p.get_msg_size()

        # find the start node
        def from_dram(p):
            return all("dram" in src.root["buffer_type"] for src in p.src_buffers())

        queue = deque()
        for p in pipes.values():
            # no dependent nodes and all sources in dram
            if p.dep_size == 0 and from_dram(p):
                queue.append(p)

        # BFS to traverse the pipe graph
        visited = set()
        while queue:
            p = queue.popleft()
            visited.add(p)

            # FIXME: CNSim do not support collectives such as multicast / gather / broadcast for now, so we need to translate 
            # the collectives to unicast packets right now. It could greatly hurts performance. 
            packets = p.pipe_to_packets()

            # TODO: Check tt-buda/backend for computation time, may be we could calculate it with op name in direct_pt_netlist.yaml
            print("\n".join(str(p) for p in packets), file=out_file)    

            for child in p.succeed_pipes():
                if child not in visited:
                    child.dep_size -= 1
                    if child.dep_size == 0:
                        queue.append(child)


if __name__ == "__main__":
    # simple_list = SimpNetlist("/home/tt-buda/direct_pt_netlist.yaml", "/home/tt-buda/net2pipe_output")
    # [GrayskullDevice(0, "grayskull", {}, "/home/tt-buda/third_party/budabackend/device/grayskull_10x12.yaml", None)]

    netlist = "/home/tt-buda/results/smoke_test/smoke_test_netlist.yaml"
    rundir = "/home/tt-buda/results/smoke_test/net2pipe_output"
    
    simple_list = SimpleNetList(
        netlist_filepath=netlist, 
        rundir=rundir,
        devices = Device.create("wormhole", 0, {}, "/home/tt-buda/third_party/budabackend/device/wormhole_b0_80_arch.yaml", None)
    )
    # DEBUG
    with open("example.trace", "w") as of: 
        generate_trace(simple_list, of)
    
    # out_trace = NTTrace()
    # generate_trace(simple_list, out_trace)
    # out_trace.nt_print_trace()